var Koth = artifacts.require("./Koth.sol");
var KothEx = artifacts.require("./KothEx.sol");

var kothInstance;
var attackerInstance;

var kothAddress;
var attackerAddress;

var accounts;

var attackerWalletBefore;
var attackerWalletAfter;

beforeEach('setup contract for each test', async function () {
  kothInstance = null;
  attackerInstance = null;

  kothAddress = null;
  attackerAddress = null;

  attackerWalletBefore = null;
  attackerWalletAfter = null;
});

function initialStats(accounts, instance) {

  console.log("kothAddress:" + kothAddress);
  console.log("attackerAddress:" + attackerAddress);

  console.log("Account[1] balance before deposit: " + web3.fromWei(attackerWalletBefore));
  console.log("Account[1] balance after deposit: " + web3.fromWei(web3.eth.getBalance(accounts[1]).toString(10)));
  console.log("attackerAddress balance after deposit: " + web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10)));

  return;
}

function checkBalances(accounts, _expected) {
  var attackerAddressBalance = web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10));
  console.log("attackerAddress balance after withdraw: " + attackerAddressBalance);
  return attackerInstance.bailOut({ from: accounts[1] }).then(function (resp) {
    const rcpt = web3.eth.getTransactionReceipt(resp.tx);
	const tx = web3.eth.getTransaction(resp.tx);
    console.log("gasUsed: " + rcpt.gasUsed);
	console.log("cumulativeGasUsed: " + rcpt.cumulativeGasUsed);
    console.log("network gasPrice: " + web3.eth.gasPrice);
	console.log("transaction gasPrice: " + tx.gasPrice);

    const transactionCost = (tx.gasPrice.mul(rcpt.cumulativeGasUsed));

    console.log("transactionCost: " + transactionCost);
    console.log("Account[1] balance after withdraw: " + web3.fromWei(web3.eth.getBalance(accounts[1])));

    attackerWalletAfter = web3.eth.getBalance(accounts[1]);
    const walletDifference = ((attackerWalletAfter.minus(attackerWalletBefore)).add(transactionCost)).valueOf();
	
	console.log("walletDifference: " + web3.fromWei(walletDifference) + " ether");
    assert.equal(web3.fromWei(walletDifference), _expected, _expected + " wasn't the wallet difference.");
  });
}

function withdraw(accounts) {

    return attackerInstance.withdraw({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      return checkBalances(accounts, 6);
    })
}

function withdrawFix1(accounts) {
  try {
    return attackerInstance.withdrawFix1({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      assert.fail;
      //return checkBalances(accounts);
    })
    .catch(function(error){
      console.log("Exception1:" + error.toString());
    }).then(function() {
      console.log("Error caught. Proceeding to check and verify wallet balances.");
      return checkBalances(accounts, 0);
    });
  } catch (error) {
    console.log("Exception2:" + error.message);
  }
}

function withdrawFix2(accounts) {
  try {
    return attackerInstance.withdrawFix2({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      assert.fail;
      //return checkBalances(accounts);
    })
    .catch(function(error){
      console.log("Exception:" + error.toString());
    }).then(function() {
      console.log("Error caught. Proceeding to check and verify wallet balances.");
      return checkBalances(accounts, 0);
    });
  } catch (error) {
    console.log("Exception:" + error.message);
  }
}

function attack(accounts, attackPrice) {
    return attackerInstance.AttackKoth(web3.toWei(attackPrice, "ether"), { from: web3.eth.accounts[1]}).then(function (resp) {
    console.log(resp.tx);
  });
}


contract('Koth', function (accounts) {
  it("should make the attacker the king of ether hill for ever.", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;
	  attackerWalletBefore = web3.eth.getBalance(accounts[1]);
	  
      return KothEx.new(kothAddress, {from:web3.eth.accounts[1], value: web3.toWei(10, "ether")}).then(function (kothExInstance) {
		  
		attackerInstance = kothExInstance;
		attackerAddress = attackerInstance.address;
		
		
        return initialStats(accounts, kothExInstance);
      }).then(() => {
        return attack(accounts, 1);
      }).then(() => {
		  return attack(accounts, 3);
      });;
    });
  });
});

/*
contract('Koth', function (accounts) {
  it("should fail the attack with fix1", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;

      return KothEx.new(kothAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix1(accounts);
      });
    });
  });
});

contract('Koth', function (accounts) {
  it("should fail the attack with fix2", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;

      return KothEx.new(kothAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix2(accounts);
      });
    });
  });
});

  /*  
    it("should call a function that depends on a linked library", function() {
      var koth;
      var KothBalance;
      var KothEthBalance;
  
      return Koth.deployed().then(function(instance) {
        koth = instance;
        return koth.getBalance.call(accounts[0]);
      }).then(function(outCoinBalance) {
        KothBalance = outCoinBalance.toNumber();
        return koth.getBalanceInEth.call(accounts[0]);
      }).then(function(outCoinBalanceEth) {
        KothEthBalance = outCoinBalanceEth.toNumber();
      }).then(function() {
        assert.equal(KothEthBalance, 2 * KothBalance, "Library function returned unexpected function, linkage may be broken");
      });
    });
    it("should send coin correctly", function() {
      var koth;
  
      // Get initial balances of first and second account.
      var account_one = accounts[0];
      var account_two = accounts[1];
  
      var account_one_starting_balance;
      var account_two_starting_balance;
      var account_one_ending_balance;
      var account_two_ending_balance;
  
      var amount = 10;
  
      return Koth.deployed().then(function(instance) {
        koth = instance;
        return koth.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_starting_balance = balance.toNumber();
        return koth.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_starting_balance = balance.toNumber();
        return koth.sendCoin(account_two, amount, {from: account_one});
      }).then(function() {
        return koth.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_ending_balance = balance.toNumber();
        return koth.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_ending_balance = balance.toNumber();
  
        assert.equal(account_one_ending_balance, account_one_starting_balance - amount, "Amount wasn't correctly taken from the sender");
        assert.equal(account_two_ending_balance, account_two_starting_balance + amount, "Amount wasn't correctly sent to the receiver");
      });
    });
    
});
*/
