var Koth = artifacts.require("./Koth.sol");
var KothEx = artifacts.require("./KothEx.sol");

var kothInstance;
var attackerInstance;

var kothAddress;
var attackerAddress;

var accounts;

var attackerWalletBefore;
var attackerWalletAfter;

beforeEach('setup contract for each test', async function () {
  kothInstance = null;
  attackerInstance = null;

  kothAddress = null;
  attackerAddress = null;

  attackerWalletBefore = null;
  attackerWalletAfter = null;
});

function initialStats(accounts, instance) {
	
	console.log("attackerAddress:" + attackerAddress);
/*
  console.log("kothAddress:" + kothAddress);
  console.log("Account[1] balance before deposit: " + web3.fromWei(attackerWalletBefore));
  console.log("Account[1] balance after deposit: " + web3.fromWei(web3.eth.getBalance(accounts[1]).toString(10)));
  console.log("attackerAddress balance after deposit: " + web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10)));
 */

  return;
}

function attack(accounts, attackPrice, fromAccount) {
	console.log("attackerAddress balance before attack call: " + web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10)));
	console.log("");
	return kothInstance.getKing({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
    console.log("Current King: " + resp);
	})
	.then( () => {
		return kothInstance.getCurrentAttackPrice({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
			console.log("Current attack price: " + resp);
		});
	})
	.then( () => {
		
		try {
		return attackerInstance.AttackKoth(web3.toWei(attackPrice, "ether"), { from: web3.eth.accounts[fromAccount]}).then(function (resp) {
			console.log();
		});	
		} catch (error){
			console.log(error.message);
		}		
	})
	.then( () => {
		return kothInstance.getKing({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
				console.log("New King: " + resp);
				console.log("");
				console.log("_______________");
				console.log("");
		});
		
	});
}

function attackFixed(accounts, attackPrice, fromAccount) {
	console.log("attackerAddress balance before attack call: " + web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10)));
	console.log("");
	return kothInstance.getKing({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
    console.log("Current King: " + resp);
	})
	.then( () => {
		return kothInstance.getCurrentAttackPrice({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
			console.log("Current attack price: " + resp);
		});
	})
	.then( () => {
		return attackerInstance.AttackKothFixed(web3.toWei(attackPrice, "ether"), { from: web3.eth.accounts[fromAccount]}).then(function (resp) {
			console.log();
		});			
	})
	.then( () => {
		return kothInstance.getKing({ from: web3.eth.accounts[fromAccount]}).then(function (resp) {
				console.log("New King: " + resp);
				console.log("");
				console.log("_______________");
				console.log("");
		});
		
	});
}


contract('Koth', function (accounts) {
  it("should make the attacker the king of ether hill for ever.", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;
	  attackerWalletBefore = web3.eth.getBalance(accounts[1]);
	  
      return KothEx.new(kothAddress, {from:web3.eth.accounts[1], value: web3.toWei(10, "ether")}).then(function (kothExInstance) {
		  
		attackerInstance = kothExInstance;
		attackerAddress = attackerInstance.address;
		
		
        return initialStats(accounts, kothExInstance);
      }).then(() => {
        return attack(accounts, 1, 1);
      }).then(() => {
		  try {
			return attack(accounts, 3, 0);
		  } catch(error) {
			 console.log(error.message);
		  }
      });
    });
  });
});

contract('Koth', function (accounts) {
  it("shouldn't make the attacker the eternal king.", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;
	  attackerWalletBefore = web3.eth.getBalance(accounts[1]);
	  
	  return KothEx.new(kothAddress, {from:web3.eth.accounts[1], value: web3.toWei(10, "ether")}).then(function (kothExInstance) {
		  
		attackerInstance = kothExInstance;
		attackerAddress = attackerInstance.address;
				
        return initialStats(accounts, kothExInstance);
      }).then(() => {
        return attackFixed(accounts, 1, 1);
      }).then(() => {
		return attackFixed(accounts, 3, 0);
      });
    });
  });
});

/*
contract('Koth', function (accounts) {
  it("should fail the attack with fix1", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;

      return KothEx.new(kothAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix1(accounts);
      });
    });
  });
});

contract('Koth', function (accounts) {
  it("should fail the attack with fix2", function () {
    return Koth.deployed().then(function (instance) {
      kothInstance = instance;
      kothAddress = kothInstance.address;

      return KothEx.new(kothAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix2(accounts);
      });
    });
  });
});

  /*  
    it("should call a function that depends on a linked library", function() {
      var koth;
      var KothBalance;
      var KothEthBalance;
  
      return Koth.deployed().then(function(instance) {
        koth = instance;
        return koth.getBalance.call(accounts[0]);
      }).then(function(outCoinBalance) {
        KothBalance = outCoinBalance.toNumber();
        return koth.getBalanceInEth.call(accounts[0]);
      }).then(function(outCoinBalanceEth) {
        KothEthBalance = outCoinBalanceEth.toNumber();
      }).then(function() {
        assert.equal(KothEthBalance, 2 * KothBalance, "Library function returned unexpected function, linkage may be broken");
      });
    });
    it("should send coin correctly", function() {
      var koth;
  
      // Get initial balances of first and second account.
      var account_one = accounts[0];
      var account_two = accounts[1];
  
      var account_one_starting_balance;
      var account_two_starting_balance;
      var account_one_ending_balance;
      var account_two_ending_balance;
  
      var amount = 10;
  
      return Koth.deployed().then(function(instance) {
        koth = instance;
        return koth.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_starting_balance = balance.toNumber();
        return koth.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_starting_balance = balance.toNumber();
        return koth.sendCoin(account_two, amount, {from: account_one});
      }).then(function() {
        return koth.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_ending_balance = balance.toNumber();
        return koth.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_ending_balance = balance.toNumber();
  
        assert.equal(account_one_ending_balance, account_one_starting_balance - amount, "Amount wasn't correctly taken from the sender");
        assert.equal(account_two_ending_balance, account_two_starting_balance + amount, "Amount wasn't correctly sent to the receiver");
      });
    });
    
});
*/
