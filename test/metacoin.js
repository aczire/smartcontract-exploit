var MetaCoin = artifacts.require("./MetaCoin.sol");
var MetaCoinEx = artifacts.require("./MetaCoinEx.sol");

var metaInstance;
var attackerInstance;

var metaAddress;
var attackerAddress;

var accounts;

var attackerWalletBefore;
var attackerWalletAfter;

beforeEach('setup contract for each test', function () {
  metaInstance = null;
  attackerInstance = null;

  metaAddress = null;
  attackerAddress = null;

  attackerWalletBefore = null;
  attackerWalletAfter = null;
});

function initialize(accounts, instance) {
  attackerInstance = instance;
  attackerAddress = attackerInstance.address;
  attackerWalletBefore = web3.eth.getBalance(accounts[1]);

  console.log("metaAddress:" + metaAddress);
  console.log("attackerAddress:" + attackerAddress);

  console.log("metaAddress balance before deposit: " + web3.fromWei(web3.eth.getBalance(metaAddress).toString(10)));

  console.log("Account[0] balance before deposit: " + web3.fromWei(web3.eth.getBalance(accounts[0]).toString(10)));
  console.log("Account[1] balance before deposit: " + web3.fromWei(web3.eth.getBalance(accounts[1]).toString(10)));

  return;
}

function checkBalances(accounts, _expected) {
  var attackerAddressBalance = web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10));
  console.log("attackerAddress balance after withdraw: " + attackerAddressBalance);
  return attackerInstance.bailOut({ from: accounts[1] }).then(function (resp) {
    const rcpt = web3.eth.getTransactionReceipt(resp.tx);
	const tx = web3.eth.getTransaction(resp.tx);
    console.log("gasUsed: " + rcpt.gasUsed);
	console.log("cumulativeGasUsed: " + rcpt.cumulativeGasUsed);
    console.log("network gasPrice: " + web3.eth.gasPrice);
	console.log("transaction gasPrice: " + tx.gasPrice);

    const transactionCost = (tx.gasPrice.mul(rcpt.cumulativeGasUsed));

    console.log("transactionCost: " + transactionCost);
    console.log("Account[1] balance after withdraw: " + web3.fromWei(web3.eth.getBalance(accounts[1])));

    attackerWalletAfter = web3.eth.getBalance(accounts[1]);
    const walletDifference = ((attackerWalletAfter.minus(attackerWalletBefore)).add(transactionCost)).valueOf();
	
	console.log("walletDifference: " + web3.fromWei(walletDifference) + " ether");
    assert.equal(web3.fromWei(walletDifference), _expected, _expected + " wasn't the wallet difference.");
  });
}

function withdraw(accounts) {

    return attackerInstance.withdraw({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      return checkBalances(accounts, 6);
    })
}

function withdrawFix1(accounts) {
  try {
    return attackerInstance.withdrawFix1({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      assert.fail;
      //return checkBalances(accounts);
    })
    .catch(function(error){
      console.log("Exception1:" + error.toString());
    }).then(function() {
      console.log("Error caught. Proceeding to check and verify wallet balances.");
      return checkBalances(accounts, 0);
    });
  } catch (error) {
    console.log("Exception2:" + error.message);
  }
}

function withdrawFix2(accounts) {
  try {
    return attackerInstance.withdrawFix2({ value: web3.toWei(1, "ether"), gas: 1000000 }).then(function () {
      assert.fail;
      //return checkBalances(accounts);
    })
    .catch(function(error){
      console.log("Exception:" + error.toString());
    }).then(function() {
      console.log("Error caught. Proceeding to check and verify wallet balances.");
      return checkBalances(accounts, 0);
    });
  } catch (error) {
    console.log("Exception:" + error.message);
  }
}

function deposit(accounts) {
  try {
    return metaInstance.deposit({ from: accounts[0], value: web3.toWei(5, "ether") }).then(function (resp) {
      //waitForTransaction(); // Truffle uses instant mining, not needed.

      const rcpt = web3.eth.getTransactionReceipt(resp.tx);
      console.log("cumulativeGasUsed: " + rcpt.cumulativeGasUsed.toString());
      
      return metaInstance.balanceOf.call({ from: accounts[0] }).then(function (balance) {
        const contractBalance = balance;
        console.log("Account[0] balance in contract after deposit: " + web3.fromWei(contractBalance));
        console.log("Account[0] balance after deposit: " + web3.fromWei(web3.eth.getBalance(accounts[0]).toString(10)));
        console.log("metaAddress balance after deposit: " + web3.fromWei(web3.eth.getBalance(metaAddress).toString(10)));

        console.log("attackerAddress balance before withdraw: " + web3.fromWei(web3.eth.getBalance(attackerAddress).toString(10)));

        return;
      });
    });
  } catch (error) {
    console.log(error.message);
  }
}


contract('MetaCoin', function (accounts) {
  it("should put 6 Ether in the attacker wallet", function () {
    return MetaCoin.deployed().then(function (instance) {
      metaInstance = instance;
      metaAddress = metaInstance.address;

      return MetaCoinEx.new(metaAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdraw(accounts);
      }).then(() => {
        // transfer it back to accounts[0]
        //cleanup();
      });;
    });
  });
});

contract('MetaCoin', function (accounts) {
  it("should fail the attack with fix1", function () {
    return MetaCoin.deployed().then(function (instance) {
      metaInstance = instance;
      metaAddress = metaInstance.address;

      return MetaCoinEx.new(metaAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix1(accounts);
      });
    });
  });
});

contract('MetaCoin', function (accounts) {
  it("should fail the attack with fix2", function () {
    return MetaCoin.deployed().then(function (instance) {
      metaInstance = instance;
      metaAddress = metaInstance.address;

      return MetaCoinEx.new(metaAddress).then(function (instance) {
        return initialize(accounts, instance);
      }).then(() => {
        return deposit(accounts);
      }).then(() => {
        return withdrawFix2(accounts);
      });
    });
  });
});

  /*  
    it("should call a function that depends on a linked library", function() {
      var meta;
      var MetaCoinBalance;
      var MetaCoinEthBalance;
  
      return MetaCoin.deployed().then(function(instance) {
        meta = instance;
        return meta.getBalance.call(accounts[0]);
      }).then(function(outCoinBalance) {
        MetaCoinBalance = outCoinBalance.toNumber();
        return meta.getBalanceInEth.call(accounts[0]);
      }).then(function(outCoinBalanceEth) {
        MetaCoinEthBalance = outCoinBalanceEth.toNumber();
      }).then(function() {
        assert.equal(MetaCoinEthBalance, 2 * MetaCoinBalance, "Library function returned unexpected function, linkage may be broken");
      });
    });
    it("should send coin correctly", function() {
      var meta;
  
      // Get initial balances of first and second account.
      var account_one = accounts[0];
      var account_two = accounts[1];
  
      var account_one_starting_balance;
      var account_two_starting_balance;
      var account_one_ending_balance;
      var account_two_ending_balance;
  
      var amount = 10;
  
      return MetaCoin.deployed().then(function(instance) {
        meta = instance;
        return meta.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_starting_balance = balance.toNumber();
        return meta.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_starting_balance = balance.toNumber();
        return meta.sendCoin(account_two, amount, {from: account_one});
      }).then(function() {
        return meta.getBalance.call(account_one);
      }).then(function(balance) {
        account_one_ending_balance = balance.toNumber();
        return meta.getBalance.call(account_two);
      }).then(function(balance) {
        account_two_ending_balance = balance.toNumber();
  
        assert.equal(account_one_ending_balance, account_one_starting_balance - amount, "Amount wasn't correctly taken from the sender");
        assert.equal(account_two_ending_balance, account_two_starting_balance + amount, "Amount wasn't correctly sent to the receiver");
      });
    });
    
});
*/
