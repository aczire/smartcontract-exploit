pragma solidity ^0.4.8;

contract MetaCoin {
    mapping (address => uint) public balances;

    function MetaCoin() public payable {
		//;
    }

    function balanceOf() view public returns(uint) {
        return(balances[msg.sender]);
    }

    function deposit() public payable {
        balances[msg.sender] = msg.value;
    }

    function withdraw() public {
      
        // The vulnerability here is,
		// if msg.sender is a contract (even some wallets like Mist allows
		// contract address as wallet address),
		// it will call its callback function.
		// The callback function can inturn call the withdraw again,
		// running in a loop.
		
		if (!msg.sender.call.value(balances[msg.sender])()) {
            revert();
        }
		
        balances[msg.sender] = 0;
    }

    function withdrawFix1() public {

		//require(balances[msg.sender] > 0);
		//require(this.balance > 0);

        //Fix 1. Change the state before the transaction call.
		balances[msg.sender] = 0;
			
		if (!msg.sender.call.value(balances[msg.sender])()) {
            revert();
        }
    }

    function withdrawFix2() public {

		//require(balances[msg.sender] > 0);
		//require(this.balance > 0);

		//Fix 2. Change call.value to safe api `send` or `transfer`.

		// send & transfer will transfer 2300 gas just to execute the callback.
		// This will also make sure another call cannot be made from
		// the callback function.
		// send() is bit risky since it will not propogate exceptions,
		
		msg.sender.transfer(balances[msg.sender]);		
        balances[msg.sender] = 0;
    }        

    function() public {
        revert();
    }
}
