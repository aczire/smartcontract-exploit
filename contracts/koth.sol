pragma solidity ^0.4.19;

/**
 * @title King of the Hill
 * @dev A user pays the king the "attackPrice" to take over the
 * @dev hill for 1 more Ether than that king paid.
**/
contract Koth {

    event ThroneChange(address king, address previousKing, uint256 attackPrice);


    address public king;
	address public previousKing;
    uint256 public attackPrice; 
	uint256 public attackPriceInc = 1 ether;
    
    mapping(address => uint) refunds;
	   
    function Koth() public {
        king = msg.sender;
		previousKing = king;
        attackPrice = 1 ether;
		refunds[king] = 0;
    }
	
	/**
     * @dev Pay to take the hill from the current king.
    **/
    function attackHill() external payable {
        require(msg.value >= attackPrice);
        
		// The vulnerability here is, in any case this `transfer` fails,
		// the transactions will get reverted.
		// So by implementing a smart contract with a callback function 
		// that `throw` by default and making it the king will
		// make sure the throne is not claimable
		// by anyone thereafter.
        king.transfer(msg.value);
        king = msg.sender;
        
        attackPrice += 1 ether;
    }

    /**
     * @dev Utility function to return the current king.
    **/	
	function getKing() external constant returns (address){
		return king;
	}

    /**
     * @dev Utility function to return the current attack price.
    **/	
	function getCurrentAttackPrice() external constant returns (uint256){
		return attackPrice;
	}	
	
    
    /**
     * @dev Pay to take the hill from the current king.
    **/
    function attackHillFixed() external payable {
        require(msg.value >= attackPrice);
		require(msg.sender != address(0)); // Accept only valid addresses.
	   
        previousKing = king;
        king = msg.sender;
		uint256 previousRefund = refunds[previousKing];
		
        refunds[king] = 0; // mappings are initialized to 0 by default, 
						   // so it should be ok to `refunds[previousKing]+= msg.value`
							
        attackPrice = msg.value + attackPriceInc;
 
        refunds[previousKing] = previousRefund + msg.value;
        ThroneChange(msg.sender, previousKing, msg.value); // Let the previousKing know.
    }

    /**
     * @dev Pay to take the hill from the current king.
    **/
    function claimRefund() external {
        uint refund = refunds[msg.sender];
        require(refund > 0);

        refunds[msg.sender] = 0;
        msg.sender.transfer(refund);    
	}

}
